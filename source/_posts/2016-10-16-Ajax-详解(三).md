---
title: Ajax 详解(三)
date: 2016-10-16 23:11:29
updated: 2016-10-16 23:11:29
tags:
categories: Ajax
feature:
---

### 一、监测进度

XMLHttpRequest 提供了各种在请求被处理期间发生的事件以供监听。这包括定期进度通知、 错误通知，等等。

支持 DOM 的 progress 事件监测之于 XMLHttpRequest 传输，遵循 Web API 进度事件规范 : 这些事件实现了 ProgressEvent 接口。

```javascript
var req = new XMLHttpRequest();

req.addEventListener("progress", updateProgress, false);
req.addEventListener("load", transferComplete, false);
req.addEventListener("error", transferFailed, false);
req.addEventListener("abort", transferCanceled, false);

req.open();

...

// progress on transfers from the server to the client (downloads)
function updateProgress(evt) {
  if (evt.lengthComputable) {
    var percentComplete = evt.loaded / evt.total;
    ...
  } else {
    // Unable to compute progress information since the total size is unknown
  }
}

function transferComplete(evt) {
  alert("The transfer is complete.");
}

function transferFailed(evt) {
  alert("An error occurred while transferring the file.");
}

function transferCanceled(evt) {
  alert("The transfer has been canceled by the user.");
}
```

第 3-6 行为多种事件添加了事件监听，这些事件在使用 XMLHttpRequest 执行数据传输时被发出。

注意： 你需要在请求调用 open() 之前添加事件监听。否则 progress 事件将不会被触发。
在上个例子中，progress 事件被指定由 updateProgress() 函数处理，并接收到传输的总字节数和已经传输的字节数，它们分别在事件对象的 total 和 loaded 属性里。但是如果 lengthComputable 属性的值是 false，那么意味着总字节数是未知并且 total 的值为零。

progress 事件同时存在于下载和上传的传输。下载相关事件在 XMLHttpRequest 对象上被触发，就像上面的例子一样。上传相关事件在 XMLHttpRequest.upload 对象上被触发，像下面这样：

```javascript
var req = new XMLHttpRequest();

req.upload.addEventListener("progress", updateProgress);
req.upload.addEventListener("load", transferComplete);
req.upload.addEventListener("error", transferFailed);
req.upload.addEventListener("abort", transferCanceled);

req.open();
```

注意：progress 事件在使用 file: 协议的情况下是无效的。

```javascript
req.addEventListener("loadend", loadEnd, false);

function loadEnd(evt) {
  alert("The transfer finished (although we don't know if it succeeded or not).");
}
```
需要注意的是，没有方法可以确切的知道 loadend 事件接收到的信息是来自何种条件引起的操作终止；但是你可以在所有传输结束的时候使用这个事件处理。


### 二、提交表单和上传文件

XMLHttpRequest 的实例有两种方式提交表单：

1. 使用 AJAX
2. 使用 FormData API

第二种方式（ 使用 FormData API ）是最简单最快捷的，但是缺点是被收集的数据不是字符串形式的。
第一种方式反而是最复杂的但也是最灵活和最强大。

只使用 XMLHttpRequest

在大多数用例中，提交表单时即便不使用 FormData API 也不会要求其他的 API。唯一的例外情况是，如果你要上传一个或多个文件，你需要额外的 FileReader API。

提交方法简介

一个 html <form> 可以用以下四种方式发送：

1. 使用 POST 方法，并设置 enctype 属性为 application/x-www-form-urlencoded (默认)
2. 使用 POST 方法，并设置 enctype 属性为 text/plain
3. 使用 POST 方法，并设置 enctype 属性为 multipart/form-data
4. 使用 GET 方法（这种情况下 enctype 属性会被忽略）

现在，我们提交一个表单，它里面有两个字段，分别被命名为 foo 和 baz。如果你用 POST 方法，那么服务器将会接收到一个字符串类似于下面三种情况之一，其中的区别依赖于你采用何种编码类型：

```javascript
方法: POST;
编码类型: application/x-www-form-urlencoded (default):
Content-Type: application/x-www-form-urlencoded
foo=bar&baz=The+first+line.&#37;0D%0AThe+second+line.%0D%0A

方法: POST;
编码类型: text/plain:
Content-Type: text/plain

foo=bar
baz=The first line.
The second line.

方法: POST;
编码类型: multipart/form-data:
Content-Type: multipart/form-data; boundary=---------------------------314911788813839

-----------------------------314911788813839
Content-Disposition: form-data; name="foo"

bar
-----------------------------314911788813839
Content-Disposition: form-data; name="baz"

The first line.
The second line.

-----------------------------314911788813839--

相反的，如果你用 GET 方法，一个像下面这样的字符串将被简单的附加到 URL：

?foo=bar&baz=The%20first%20line.%0AThe%20second%20line.
```

### 三、绕过缓存

一般地，如果缓存中有相应内容， XMLHttpRequest 会试图从缓存中读取内容。绕过缓存的方法见下述代码：

```javascript
var req = new XMLHttpRequest();
req.open('GET', url, false);
req.channel.loadFlags |= Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE;
req.send(null);
Note: This approach will only work in Gecko-based software, as the channel attribute is Gecko-specific.
```

或者还有一个跨浏览器兼容的方法，就是给 URL 添加时间戳。请确保你酌情地添加了 "?" or "&" 。例如，将：

```javascript
http://foo.com/bar.html
改为

http://foo.com/bar.html?12345
以及将

http://foo.com/bar.html?foobar=baz
改为

http://foo.com/bar.html?foobar=baz&12345
```
因为本地缓存都是以 URL 作为索引的，这样就可以使每个请求都是唯一的，也就可以这样来绕开缓存。

你也可以用下面的方法自动更改缓存：

```javascript
var req = new XMLHttpRequest();
req.open("GET", url += ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime(), false);
req.send(null); 
```

### 四、Sending and Receiving Binary Data

#### 1. 使用 JavaScript 类型数组接受二进制数据

可以通过设置一个 XMLHttpRequest 对象的 `responseType` 属性来 **改变一个从服务器上返回的响应的数据类型**.可用的属性值为空字符串 (默认), "arraybuffer", "blob", "document", 和 "text". response 属性的值会根据 responseType 属性的值的不同而不同, 可能会是一个 ArrayBuffer, Blob, Document, string,或者为NULL(如果请求未完成或失败)

下例读取了一个二进制图像文件,并且由该文件的二进制原生字节创建了一个8位无符号整数的数组.

```javascript
var oReq = new XMLHttpRequest();
oReq.open("GET", "/myfile.png", true);
oReq.responseType = "arraybuffer";

oReq.onload = function (oEvent) {
  var arrayBuffer = oReq.response; // 注意:不是oReq.responseText
  if (arrayBuffer) {
    var byteArray = new Uint8Array(arrayBuffer);
    for (var i = 0; i < byteArray.byteLength; i++) {
      // 对数组中的每个字节进行操作
    }
  }
};

oReq.send(null);
```

除了上面的方法,还可以使用 BlobBuilder API 直接将 arraybuffer 数据添加进一个 Blob 对象中, 由于 **该 API 还在试验阶段,所以需要加上特定的前缀**:

```javascript
var BlobBuilder = window.MozBlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;
var oReq = new XMLHttpRequest();
oReq.open("GET", "/myfile.png", true);
oReq.responseType = "arraybuffer";

oReq.onload = function(oEvent) {
  var blobBuilder = new BlobBuilder();
  blobBuilder.append(oReq.response);
  var blob = blobBuilder.getBlob("image/png");
  // ...
};

oReq.send();
```

#### 2. 在老的浏览器中接受二进制数据

下面的 load_binary_resource() 方法可以从指定的 URL 那里加载二进制数据,并将数据返回给调用者.

```javascript
function load_binary_resource(url) {
  var req = new XMLHttpRequest();
  req.open('GET', url, false);
  //XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]
  req.overrideMimeType('text/plain; charset=x-user-defined');
  req.send(null);
  if (req.status != 200) return '';
  return req.responseText;
}
```

** 最为奇妙的操作在第五行,该行重写了默认的 `MIME`类型,强制浏览器将该响应当成纯文本文件来对待, 使用一个用户自定义的字符集.这样就是告诉了浏览器,不要去解析数据,直接返回未处理过的字节码.**

```javascript
var filestream = load_binary_resource(url);
var abyte = filestream.charCodeAt(x) & 0xff; // 扔掉的高位字节(f7)
```

上例从请求回来的二进制数据中得到偏移量为 x 处的字节.有效的偏移量范围是 0 到 filestream.length-1.


#### 3. 发送二进制数据
XMLHttpRequest 对象的 send 方法已被增强,可以通过简单的传入一个 ArrayBuffer, Blob, 或者 File 对象来发送二进制数据.

下例创建了一个文本文件,并使用 POST 方法将该文件发送到了服务器上.你也可以使用文本文件之外的其他二进制数据类型.

```javascript
var oReq = new XMLHttpRequest();
oReq.open("POST", url, true);
oReq.onload = function (oEvent) {
  // 上传完成后.
};

var bb = new BlobBuilder(); // 需要合适的前缀: window.MozBlobBuilder 或者 window.WebKitBlobBuilder
bb.append('abc123');

oReq.send(bb.getBlob('text/plain'));
```

#### 4. 将类型数组作为二进制数据发送

你可以将 JavaScript 类型数组作为二进制数据发送出去.

```javascript
var myArray = new ArrayBuffer(512);
var longInt8View = new Uint8Array(myArray);

for (var i=0; i< longInt8View.length; i++) {
  longInt8View[i] = i % 255;
}

var xhr = new XMLHttpRequest;
xhr.open("POST", url, false);
xhr.send(myArray);
```

上例新建了一个 512 字节的 8 位整数数组并发送它,当然,你也可以发送任意的二进制数据.

注意: 从Gecko 9.0 (Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6)开始,添加了使用XMLHttpRequest发送 ArrayBuffer对象的功能.

### 参考
- [Using XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)
- [Sending and Receiving Binary Data](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data)