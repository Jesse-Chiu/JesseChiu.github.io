---
title: 微信填坑
date: 2017-07-28 14:34:39
updated: 2017-07-28 14:34:39
categories: WeChat
---

> 在微信开发过程中，经常会碰到各种坑，本文主要是记录在开发过程中遇到的坑，以便后期查询。

## 一、遇到的坑
### 1.1 端口
公众平台接口调用仅支持 `80` 端口

### 1.2 access_token
公众平台以 access_token 为接口调用凭据，来调用接口，所有接口的调用需要先获取 access_token，access_token 在 2 小时内有效，过期需要重新获取，但1天内获取次数有限，开发者需自行存储，详见获取接口调用凭据（access_token）文档。

### 1.3 40037
如果后台返回 40037 表示微信测试账号，模板ID只能通过微信测试账号，新增的模板id才有效。[参考](http://zhengyunfei.iteye.com/blog/2228950)

### 1.4 40163
参考: [微信网页授权 40163 code已被使用过](https://segmentfault.com/q/1010000009538036?sort=created)

### 1.5 40164
是运行的 ip地址不在白公众号配置的 IP
白名单中。如果是在本地调试，在白名单里面增加本机IP就可以，如果放到线上了，则需要把白名单内的IP修改为服务器IP。
> linux 服务器获取本机外网 ip 地址方法
```bash
curl ip.cn
//当前 IP：59.60.x.x 来自：福建省福州市 电信
```
> 如果可以访问网页，直接访问 [http://ip.qq.com/](http://ip.qq.com/) 会显示你的IP地址

### 1.6 45047(客服接口下行条数超过上限)
主要是微信在 2017-12-12 升级后出现,下面是网上找到的信息。
>用户和公众号有过互动后,发送 `20` 消息后,就会出现 `45047` ,这应该是微信对单个用户的客服消息做了限制,防止公众号发送垃圾消息。
- [errcode 45047](http://www.codes51.com/itwd/1191950.html)


### 1.7 scan_push
如果需要从菜单的扫一扫跳转页面，需要使用 scan_push 类型，并且二维码内容是 url 地址。

### 1.8 jssdk
- [nodejs 微信开发--调用微信 JSSDK](http://blog.csdn.net/sinat_29843547/article/details/49357193)
- 在微信中打开的网页，关闭退出到微信
```js
window.onload = function() {
	document.getElementById('back').addEventListener('click', function(event) {
		event.preventDefault();
		WeixinJSBridge.invoke('closeWindow', {}, function(res) {});
	});
}
```
### 1.9 wechat 中间件
- wechat 中间键会改写 session 和 wxsession(且每次请求的 sessionID 值都会变，但是保存在该 session 中的值不变)这个和 express-session 相互独立，这就导致了 req.session 的内容是不一样的。WeixinJS 接口
```js
// 处理微信服务器发来的信息和事件
router.use('/', wechat(wechtConfig, (req, res, next) => {
  req.wxsession.openId = message.FromUserName;
  req.session.openId = message.FromUserName;
  console.log(`\n\n/wechat sessionID: ${req.sessionID} \nsession:${JSON.stringify(req.session)}`);
  console.log(`\n\n/wechat wxsessionID: ${req.wxsessionID} \nwxsession:${JSON.stringify(req.wxsession)}`);

  // /wechat sessionID: si2KucNK_3hVFzUBJTijkabot05-4Quw
session:{"cookie":{"originalMaxAge":86400000,"expires":"2017-07-29T08:08:25.642Z
","httpOnly":true,"path":"/"},"openId":"oS5_7v0W4VtnUASYLjJfl52qzt78"}

 // /wechat wxsessionID: undefined
wxsession:{"cookie":{"originalMaxAge":86400000,"expires":"2017-07-29T08:08:25.64
2Z","httpOnly":true,"path":"/"},"openId":"oS5_7v0W4VtnUASYLjJfl52qzt78"}

  // ...
});

// 后续处理 中间件
router.use('/xxx',(req, res, next) => {
	console.log(`\n\n+++authority sessionID: ${req.sessionID} \nsession:${JSON.stringify(req.session)}` );
	console.log(`\n\n+++authority sessionID: ${req.wxsessionID} \nwxsession:${JSON.stringify(req.wxsession)}` );
});

// +++authority sessionID: oFVDtMqEB94TgXP9X0V6Xz4QmCSCLk4S
session:{"cookie":{"originalMaxAge":86400000,"expires":"2017-07-29T08:08:26.406Z
","httpOnly":true,"path":"/"}}

// +++authority wxsessionID: undefined
wxsession:undefined

// ...
```
从上面的代码可以看出
- wechat 中间件可以使用: session 和 wxsession
- 后续路由只能访问 session 且是一个新的 session (从 sessionID 值不同可确定)
- 原理：当从 wechat 中间件的 session 和 app 中使用的 session 相互独立，互不影响。


> 由于公共平台应用的客户端实际上是微信，所以采用传统的Cookie来实现会话并不现实，为此中间件模块在openid的基础上添加了Session支持。一旦服务端启用了 `connect.session` 中间件，在业务中就可以访问req.wxsession属性。这个属性与req.session行为类似。

### 1.10 微信服务器发送三次重复的排重问题
```js
const uniqueMessageSet = new Set();
function checkIsUniqueMsg(msgId){
  if(uniqueMessageSet.has(msgId)){
    console.log(`\n<<< checkIsUniqueMsg: already have msgId -> ${uniqueMessageSet.size}\n`);
    return false;
  }else{
    uniqueMessageSet.add(msgId);
    console.log(`\n<<< checkIsUniqueMsg: add -> ${uniqueMessageSet.size}\n`);
    setTimeout((msgId)=>{
      uniqueMessageSet.delete(msgId);
      console.log(`\n<<< checkIsUniqueMsg: timeout -> ${uniqueMessageSet.size}\n`);
    },config.deleteUniqueMsgTimeout,msgId);
  }
  return true;
}
```
参考: [微信服务器发送三次重复的排重问题](http://blog.csdn.net/langren1353464539/article/details/49898067)


### 1.11 页面跳转
微信不支持在关注或者扫描处理的逻辑代码中跳转页面；也就是必须先到公众号页面，再从里面点击进入其它页面。

### 1.12 发送建议使用 reply
在 wechat 中间件里发送信息使用 `replay`，而不使用 `wechatApi.sendText`。
```js
res.reply({
  type: "text",
  content: data
});

// 使用下面的函数发送会至少需要 5s 时间才能到达微信服务器，
// 这样微信服务器在 5s 内未收到消息，就会连续发送三次
wechatApi.sendText(openId,data,(err,data)=>{
	if(err){
		logger.error(err);
		return;
	}
	console.log(`\nWechatAPI.sendText() success: ${JSON.stringify(data)}`);
});
```

### 1.13 viewEvent 错误
从菜单点击进入，如果是 `viewEvent` 页面跳转事件，会报路径查找不到错误
```js
[ERROR] lpt - POST /wechat/?signature=94b5ac8040ac4919ab2522b15827b4b3ca12573e&\timestamp=1502954629&nonce=737629849&openid=oS5_7v3io3nzrxMIVNWufQk1NrVI 404
```
这时只要添加一个根级路由，过滤即可解决
```js
// app.js
app.use('/wechat', require('./routes/lpt-index'));
// ...
// lpt-index.js
router.all('/',(req,res,next)=>{
  res.end();
});

```

### 1.14 禁止网页在浏览器打开
可以在每个页面的头部，判断下浏览器中是否包含 `MicroMessenger` 值来确认是否为微信内置浏览器
```js
<script type="text/javascript">
  (function(){
    if((window.navigator.userAgent.match('MicroMessenger') === null) && window.location.href.match('/not-wechat-navigator') === null){
      // 跳转到错误提示界面
      window.location='/wechat/not-wechat-navigator/';
      return false;
    }
  })()
</script>
```
参考: [Javascript限制网页只能在微信内置浏览器中访问](http://www.jb51.net/article/57260.htm)


### 1.15 避免微信信息使用缓存内容
当我们使用下面的代码发送信息给微信(聊天界面)时，如果微信收到的信息内容是一样(显示时)的，当再次发送同样信息时，链接内容不同时，点击操作还是使用先前的内容，也就是微信内部判断，如果显示内容一样，就是使用了缓存。
```js
function sendWelcomeMsg(msg){
  res.reply({
    type: "text",
    content: msg
  });
  res.end();
}
```
例如:下面代码:
```js
sendWelcomeMsg(`<a href="http://xxx.yy.com/?id=1234&name=jesse">点击开票</a>`)
sendWelcomeMsg(`<a href="http://xxx.yy.com/?id=888&name=jesse">点击开票</a>`)
```
微信聊天界面收到两条信息，显示的内容都是 `点击开票`,但是两条信息的链接参数不是一样的。但是点击第二条信息时，跳转链接得到的参数还是第一条的 `id=1234&name=jesse`，使用了先前的缓存内容。尝试了下面的方法还是一样:
- 链接尾部添加一个动态数据(当前时间)
- 每次发送前连接地址转换为端网址显示(端网址每次都不同)
- 在服务端和网页端，添加清除缓存代码

解决办法：
经过上面的失败尝试后，分析得出是依据显示内容来判断是否使用缓存，而且这个缓存是存在微信服务器内，所有在现实内容时，每次都添加一个不一样的参数，使用当前时间。
```js
sendWelcomeMsg(`<a href="http://xxx.yy.com/?id=1234&name=jesse">点击开票</a>\n\n当前时间:new Date()`)
sendWelcomeMsg(`<a href="http://xxx.yy.com/?id=888&name=jesse">点击开票</a>\n\n当前时间:new Date()`)
```
经过测试，解决了微信内部调整使用缓存问题。这个可以算个比较大的坑了。






## 学习资源

* [微信开发必备外网映射工具----Ngroke](http://blog.csdn.net/zt_fucker/article/details/52535407)
* [Nodejs实战之7天开发微信公众号](http://cloud.189.cn/t/6r2emymaI7Jz) 慕课网收费视频下载
* [下载地址](https://pan.baidu.com/share/init?shareid=2851851900&uk=2977776567) 提取密码: ejkr
* [node-qrcode](https://github.com/soldair/node-qrcode) // js 生成二维码工具




## 参考

* [初识Java微信公众号开发](http://www.imooc.com/learn/368) 慕课网视频教程，有些基础知识讲解
* [leancloud 微信公众平台开发指南](https://leancloud.cn/docs/webhosting_weixin.html)
* [公众号类型的接口权限说明](https://mp.weixin.qq.com/wiki/13/8d4957b72037e3308a0ca1b21f25ae8d.html)
* [全局返回码说明](https://mp.weixin.qq.com/wiki/10/6380dc743053a91c544ffd2b7c959166.html)
* [在线接口调试接口网址](https://mp.weixin.qq.com/debug)
* [云函数开发指南](https://leancloud.cn/docs/leanengine_cloudfunction_guide-node.html)
* [网站托管开发指南](https://leancloud.cn/docs/leanengine_webhosting_guide-node.html)
* [JavaScript 开发指南](https://leancloud.cn/docs/leanstorage_guide-js.html)
* [JavaScript SDK API](https://leancloud.github.io/javascript-sdk/docs/)
* [Node.js SDK API](https://github.com/leancloud/leanengine-node-sdk/blob/master/API.md)
* [命令行工具使用指南](https://leancloud.cn/docs/leanengine_cli.html)
* [云引擎常见问题和解答](https://leancloud.cn/docs/leanengine_faq.html)

