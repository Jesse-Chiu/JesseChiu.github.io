---
title: 使用 Chrome 分析内存泄漏
date: 2017-02-28 15:12:54
updated: 2017-02-28 15:12:54
tags: Chrome
categories: Tools
---


> 本文主要是记录如何通过 Chrome 的调试工具，来分析 Web App 内存泄漏

## 一、排查方法
### 1. The Timeline

`Ctrl + Shift + i` -> Timeline

如下图:
![Timeline](http://www.dwmkerr.com/content/images/2015/02/StartRecording.png)

- 点击左上角圆点，开始记录。
- 运行你的 app 应用。
- 点击停止记录。

这时你会看到类似如下图：

![](http://www.dwmkerr.com/content/images/2015/02/MemoryUsage.png)

如果是排查内存泄漏，我们要关注的是 **蓝色的线(JS Heap)**。如果我们的应用在点击某个操作会消耗比较大的内存，完成后内存应该被垃圾回收，回到原来状态，这样抓取的图应该是 **锯齿状** 的。如下图:

![](http://www.dwmkerr.com/content/images/2015/03/TimelineSawtooth.png)

如果是 **梯形** 状，那就要注意了，如下图:
![](http://www.dwmkerr.com/content/images/2015/03/TimelineSteps-1.png)

但是这并不代表就是存在内存泄漏，例如，我们允许用户不断滚动浏览图片，但是代码中并没释放之前图片。还有我们手机应用，下拉刷新列表，随着我们不断的下拉刷新，内存占用就会不断的上升。

如果是下面的图片:
![](http://www.dwmkerr.com/content/images/2015/03/TimelineLeakySawtooth.png)
初看也是 **锯齿状**，貌似正常。细看我们会发现，上图中的锯齿图会不断的往上倾斜。也就是，我们每操作一次应用，内存回收并没有到最初的点，而是，逐次的减少。这很 **可能** 就存在内存泄漏，但还需进一步确认。


### 2. Recording Heap Allocations
为了进一步确认是否存在内存泄漏，就需要用到强大的 `Profiles` 工具了，打开方法:

`Ctrl + Shift + i` -> Profiles -> Recording Heap Allocations
![](http://www.dwmkerr.com/content/images/2015/02/HeapAllocations.png)

使用该工具可以帮助我们快速看到是否有内存泄漏。使用方法:
- 点击开始录制
- 操作应用
- 回到原始操作点
- 停止录制

这时会看到类似如下的柱状图:

![](http://www.dwmkerr.com/content/images/2015/03/HeapAllocationsEx3.png)

图中的 **蓝色** 柱状图表示该操作 Chrome 保留用到的内存，**灰色** 部分表示释放的内存。
如果完全理想状态应该是，重复操作完两次 (1-2,3-4),回到最初状态应该都是灰色，但是实际情况并非如此，如果还有 **蓝色** 柱状图(如上图),可能是由于缓存原因，并非是内存泄漏。

*如果是下图，那就要注意了*:

![](http://www.dwmkerr.com/content/images/2015/03/Scenario2HeapAllocations.png)

上图是重复进入退出一个页面 10 次的抓取结果，可以看出，几乎每次都有保留 **蓝色** 柱状图，这很可能就是内存泄漏了。这时我们可以通过，组后一步的方法来确认!!!


### 3. Heap Snapshots
最后一步，分别抓取每次操作的 Heap 快照，然后进行对比排查。
打开方法：
`Ctrl + Shift + i` -> Profiles -> Heap Snapshots
![](http://www.dwmkerr.com/content/images/2015/03/TakeHeapSnapshot.png)

**注意：每次抓取都会进行内存的垃圾回收**

`Heap Snapshots vs Recording Heap Allocations`
- Heap Snapshots 看到的数据和 Recording Heap Allocations 是相同的
- Heap Snapshots: 可以查看到目前所用到的所有内存
- Recording Heap Allocations：只能看当前被引用到并实例化的 **对象**

Heap Snapshots 真正可以用来排查内存泄漏的是里面的 **快照对比** 功能，可以分析对比两次快照的差别点，例如，销毁了多少内存对象，新增了多少对象，哪些 DOM 被隔离等，并能看到相应的代码上下文，这为我们排查内存泄漏带来了很大的帮助。

#### 3.1 Analysing Memory Leaks
![](http://www.dwmkerr.com/content/images/2015/03/HeapData.png)

Constructor 列是目前所占用的内存对象实例，有的是系统创建的，有的是应用创建的。
- (compiled code): Chrome 创建的内部对象，不用考虑。
- (array): 同上，内部引用对象，不用考虑。
- system: 同上，内部引用对象，不考虑。
- Array: 应用用到的数组对象，需要关注。
- Object: 普通的 JavaScript 对象，而不是用户定义 array 或者浏览器 document 对象或者 null，它就是空 {} 或者键值对
- (closure): 闭包
- system / Context: 基础数据需要调用函数，例如闭包所使用的实际数据
- 其它：类似 `HTMLDivElement、HTMLButtonElement、HTMLElement...` 等。

![](http://od6sd4xau.bkt.clouddn.com/heap-snapshot-01.png)

#### 3.2 内存泄漏代码实例
下面是一段内存泄漏的代码
```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Memory Leak Demo</title>
</head>
<body>
    <h1>Memory Leak Demo</h1>
    <div style="margin: 5px">
		Current Num: <span id="curNum" style="text-align: center;color:red">0</span>
    </div>
    <div>
		<button id="add" onclick="addNewHeapData()">add a heap data</button>
		<button id="del" onclick="deleteHeapData()">delete a heap data</button>
    </div>
    <script type="text/javascript">
    window.funArray = [];

    // 事件绑定相关代码
    // var addEelement = document.getElementById('add');
    // function hello(){
    //     console.log('hello');
    // }

    /**
     * 模拟添加内存数据
     */
    function addNewHeapData() {
       
        //  Create a class which will hold heap data. Makes it easier 
        //  to find the data in Chrome.
        function HeapData() {}

        //  Create a heap data object.
        var heapData = new HeapData();

        //  Create a function that multiplies two numbers.
        function multiply(a, b) {
            return a * b;
        }

        //  Create a 'multiply by' function, which curries the above
        //  to generate a function which multiplies by a constant. This
        //  will involve closures. 
        var multiplyBy = function(a) {
            return function(b) {
                return multiply(a, b);
            }
        };
        //  Add some data to our heap data object.
        heapData.fry = "Philip J. Fry";
        heapData.zoidberb = "John " + "Zoidberg";
        heapData.character = {
            firstName: "Amy",
            secondName: "Wong"
        };
        heapData.double = multiplyBy(2);
        heapData.multiplyBy100 = multiplyBy(100);
        heapData.doubledNumber = heapData.double(18);
        heapData.multipliedNumber = heapData.multiplyBy100(15);
        heapData.div = document.createElement("div");
        // 添加事件绑定
        // addEelement.addEventListener('click',hello,false);

        //  Put the heap data on the window, it is now pinned to a GC root.
        // 挂载到 window 对象的属性是不能被 GC 回收
        window.funArray.push(heapData);
        setCurrentNum();
        console.log('funArray.length: ' + window.funArray.length);
    }
    function deleteHeapData(){
        // addEelement.removeEventListener('click',hello,false);
    	window.funArray.shift();
    	setCurrentNum();
    	console.log('funArray.length: ' + window.funArray.length);
    }
    function setCurrentNum(){
    	var curNum = document.getElementById('curNum');
    	curNum.innerHTML = window.funArray.length;
    }
    </script>
</body>
</html>	
```
#### 3.3 内存泄漏在线例子
[内存泄漏在线例子](https://jesse-chiu.github.io/web-memory-leak-demo/)

下面是测试的 `Heap Snapshot` 截图：
![](http://od6sd4xau.bkt.clouddn.com/demo-0.png)
![](http://od6sd4xau.bkt.clouddn.com/demo-1.png)
![](http://od6sd4xau.bkt.clouddn.com/demo-2.png)

如上图是初始化，和添加 2 次的内存快照。

图片解析:
- 每个 Constructor 都会有一个唯一 UUID()，入上面的 `HeapData @312793`
- Distance: 这个是各个实例距离 GC Root 的距离。例如上面的 demo 中，window 是全局对象(GC root),`HeapData` 距离它的值为 `3 = window -> funArray(3) -> funArray[x](2) -> heapData=new HeapData() ->(1) HeapData(构造函数)`。并且挂载到 window 下的属性是不会被 GC 的。
	- 如下图的测试代码
	![](http://od6sd4xau.bkt.clouddn.com/global-delete.png)
- Objects count: 有多少个实例对象别引用。
- Shallow Size: 对象直接占用的内存大小。
- Retained Size: 对象自身和其所应用到的对象总内存大小。 
- **上图中的背景用黄色高亮的实例，表示可以通过 `javascript` 直接访问。例如：`window.funArray[x]` 访问到。**

再来看下闭包中引用到的
![](http://www.dwmkerr.com/content/images/2015/03/HeapDataAnalysis4-1.png)
上图中可以看到，demo 中的属性引用到的闭包(`multiplyBy100`)。

再来一张
![](http://www.dwmkerr.com/content/images/2015/03/HeapDataAnalysis5.png)
上图要注意点
- `HTMLDivElement` 选中时背景是 **红色**，不选中时时 **黄色**。
- **上面的 `native:: Detached Dom tree` 那行，显示占用的内存为 0 ，这个只是表示，js 层没有分配内存，但是在 V8 engine 依然占用着。**
- **红色** 表示被隔离。也就是，存在 + 被其它对象引用着 + 不能被 GC 的对象，但是不存在于 DOM 中。如果一直在递增不是一种好的信号。

#### 3.3 Comparison
我们可以通过分别抓取两次操作的 `Heap Snapshot`,然后选择 `Comparison` 进行对比，新增了哪些对象。如下图：
![](http://od6sd4xau.bkt.clouddn.com/demo-3.png)

通过上图可以很快的查找出那些新增加的对象。

## 二、修复方法
![](http://www.dwmkerr.com/content/images/2015/03/ScopeLeakGraph2.png)
修改 bug 是个复杂的过程，这里 以 `AngularJS 1.x` 为例,介绍几个黄金准则,原理适合其它的框架。

### 1. 熟悉你使用的框架 和 它的函数生命周期
### 2. 在短生命周期和长生命周期交互地方需要特别注意
- 不要让长生命周期的函数，通过直接引用、闭包、回调等方式关联到短生命周期中的对象。
例如，angular 中的 directive、controler 和 service 之间，还有 angular 与其它库之间。


### 3. 切断引用
- 在 js 中造成内存泄都是由于被引用，GC 没办法回收引起。虽然大部分框架在页面销毁时都会这么做。但并非都是简单 `nulling` 对象或者清空数组，所以安全起见还是手动 **切断引用**。

### 4. 实例:

#### 4.1 事件绑定
Poorly:
```javascript
function(scope, element, attrs) {  
  element.on('click', function() {
    scope.selected = true;
  });
}
```
这里我们在事件回调函数的闭包中，引用到了 `scope`,如果我们未解绑该事件，`scope` 将会被一直引用。
Fix:
```javascript
function(scope, element, attrs) {  
  element.on('click', function() {
    scope.selected = true;
  });
  scope.$on('$destroy', function() {
      element.off(); // deregister all event handlers
  })''
}
```

** 注意，removeEventListener 方法移除的监听函数，必须与对应的 addEventListener 方法的参数完全一致，而且必须在同一个元素节点，否则无效。**

```javascript
function hello(){
	console.log('hello');
}
// 可以正常解绑
document.addEventListener('click',hello,false);
document.removeEventListener('click',hello,false);

// 如果是匿名的回调函数则，不能正常解绑
document.addEventListener('click',function(){
	console.log('hello');
},false);
```

#### 4.2 Watchers
Poorly:
```javascript
$scope.$on('someEvent', function() {
    $scope.refresh();
})
```
虽然框架会自动帮我们清楚，但是建议还是手动添加相应的解绑函数
Fix:
```javascript
var cleanup = $scope.$on('someEvent', function() {  
    $scope.refresh();
});
$scope.$on('$destroy', function() {
    cleanup();
})
```

#### 4.3 解耦长短生命周期函数相互引用
- Suggest one:
```javascript
// poorly:
UserService.onNameChange(function(newName) {  
    $scope.userName = newName;
});
// 通过回调函数容易造成引用释放问题
// fix:
// change and name and wait for the result
UserService.changeName("Fry").then(function(newName) {  
    $scope.name = newName;
});
```

- Suggest two:
```javascript
// more like our original example
$scope.$on('NotificationService:ChangeName', function(data) {
    $scope.name = data;
});
```
虽然不建议这么做，代价会比较高。但是这也是一个解耦方法，框架会自动清理。

#### 4.4 $rootScope.$new()
如果在 servcie 中有使用到 `$rootScope.$new()`,一定要记得在不需要时，销毁创建的子作用域。
```javascript
// ...
var childScope = $rootScope.$new();
// ...
// do some thing
childScope.$destroy();
```

#### 4.5 定时器
定时器在使用完时需要取消，尤其是 `$interval` 定时器，如果没取消会在后台一直运行。
```js
// ...
var timer_1 = $timeout(function(){
    // ...
},1000);
var timer_2 = $interval(function(){
    //...
},1000);
// ...
$scope.$on('$destroy', function () {
  $timeout.cancel(timer_1);
  $interval.cancel(timer_2);
});
```
















	













## 参考
- [Fixing Memory Leaks in AngularJS and other JavaScript Applications](http://www.dwmkerr.com/fixing-memory-leaks-in-angularjs-applications/#identifyingmemoryleaks)
- [Document、Node、Element、HTMLDocument 、HTMLCollection、HTMLElement、NodeList](http://zccst.iteye.com/blog/2172803)








