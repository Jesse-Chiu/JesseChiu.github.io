---
title: Node.js 学习札记
date: 2017-08-24 10:24:54
updated: 2017-08-24 10:24:54
categories: Node.js
---

## 服务器配置 CSP 安全策略
```js
if (config.CSP_HEADER) {
  res.set({
    'Content-Security-Policy': config.CSP_HEADER,
    'X-Content-Security-Policy': config.CSP_HEADER,
    'X-WebKit-CSP': config.CSP_HEADER
  });
 }
```

## 解析 Ajax 提交的 Json 数据
前端代码
```js
let sendData = {
  date: 1501738051000,
  marks: ["writing","drawing"]
};
$.ajax({
  url:'http://a.test.com:3000/add-mark',
  method:'POST',
  data: JSON.stringify(sendData), // 转换为 json 格式
  contentType: "application/json; charset=utf-8", // 设置提交的数据类型
});
```
node.js 端代码
```js
// ...
// bodyParser 中间件解析 json 格式
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
// ...
router.post('/add-mark',(req,res,next)=>{
	console.log(`add-mark: ${JSON.stringify(req.body)} type:${typeof req.body}`);
	// ...
});
// add-mark: {"date":1501738051000,"marks":["writing","drawing"]} type:object
```

## 向其它网站请求数据

### 1. 链接地址就是文件路径
```js
request.get('http://s0.hao123img.com/res/img/logo/logonew.png')
.on('error', function (err) {
  console.log(err)
})
.pipe(fs.createWriteStream('logo.png'))
```
### 2. 链接地址请求返回的是 302，有跳转
例如：`http://dev.fapiao.com:19080/dzfp-wx/pdf/download?request=e5uhf8WETIOMgaa2cCUMtvQOgskCy8PgqGnALxb42V6qo8a4Rk9dKYMlhdAvFCkWoAlPj8G3kZVzWvlS4wKaCg__%5EdfiEJDedFJ` 网址，如果直接贴到浏览器可以直接下载文件，但是通过上面第一种方法，得到的是下面的信息。
```js
STATUS: 302
HEADERS: {"server":"nginx/1.9.8","date":"Wed, 22 Nov 2017 02:06:36 GMT","content-length":"0","connection":"close","location":"http://dev.fapiao.com:19080/fpt-download/downloadController/download?xml=nt2pWb35DcT4vgk6vlTUJ4Xc-suWF.IRuFlnIhO4d8y4DWcygaMgFs1mMhEEOJlD%5EBACJdiehaD"}
```
当时也是调试了很久，试过了 [request](https://www.npmjs.com/package/request),`http.get`,[urllib](https://github.com/node-modules/urllib) 都不行,最后使用 [got](https://github.com/sindresorhus/got) 成功解决
```js
const fs = require('fs');
const got = require('got');
got.stream(pdfUrl).pipe(fs.createWriteStream(`${new Date().getTime()}.pdf`));
```
如果要保证文件流写完再进行下一步操作,则需要如下代码封装
```js
function gotFile(){
  return new Promise((resolve,reject)=>{
    let tempFileName = `${new Date().getTime()}.pdf`;
    console.log(`tempFileName: ${tempFileName}`);
    const writeAble = fs.createWriteStream(tempFileName);
    got.stream(pdfUrl).pipe(writeAble);
    writeAble.on('finish', () => {
      resolve(tempFileName);
    });   
    writeAble.on('error', (error) => {
      reject(error);
    });
  })
}
```
### 3.其它方法代码
方法 1：
```js
// 需要升级 nodejs 到最新版本(8.9.1)
const { URL } = require('url');
const options = new URL(pdfUrl);
console.log(`options: `,options);
const req = http.request(options, (res) => {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
  res.setEncoding('binary');
  res.on('data', (chunk) => {
    console.log(`BODY: ${chunk}`);
    var buffer = new Buffer(chunk);
    fileBuff.push(buffer);
  });
  res.on('end', () => {
    console.log('No more data in response.');
    var totalBuff = Buffer.concat(fileBuff);
    fs.writeFile(`./${new Date().getTime()}.pdf`, totalBuff, "binary", function (err) {
      if (err) {
        console.log("down fail");
      }
      console.log("down success");
    });
  });
});

req.on('error', (e) => {
  console.error(`problem with request: ${e.message}`);
});
req.end();
```
方法 2:
```js
http.get(pdfUrl, function (res) {
  res.setEncoding("binary"); //一定要设置response的编码为binary否则会下载下来的图片打不开
  res.on("data", function (chunk) {
    console.log(`data: `,chunk);
    var buffer = new Buffer(chunk);
    fileBuff.push(buffer);
  });
  res.on("end", function () {
    var totalBuff = Buffer.concat(fileBuff);
    fs.writeFile(`./${new Date().getTime()}.pdf`, totalBuff, "binary", function (err) {
      if (err) {
        console.log("down fail");
      }
      console.log("down success");
    });
  });
});
```
## 参考

- [参考](http://segmentfault.com/a/1190000000627041)